from math import sqrt
import json
import os
import requests
import sys

import numpy as np
import pandas as pd
from scipy import interpolate
from math import ceil, floor, atan2, degrees, radians


def reshapeReferences(inRefList):
    """
    Converts WND files Json references to a list of lists [valid_ts,avail_ts,rel_path] so that we can easily find which WND file is
    to use for isochrone calculation given a specific timestamp
    """

    outRefList=[]
    for refElement in inRefList :
        tmpRefList = []
        if len(refElement) > 1 :
            for elem in refElement:
                tmpRefList.append([elem['valid_ts'],elem['avail_ts'],elem['rel_path']])
            outRefList.append(tmpRefList)
        else :
            outRefList.append([refElement[0]['valid_ts'],refElement[0]['avail_ts'],refElement[0]['rel_path']])
    
    return outRefList

def findWndFile(inTimestamp,refList):
    """
    Finds the desired WND files corresponding to inTimestamp (which files need to be used for wind interpolation) from a list of all accessible WND files

    Gets : 
        - inTImestamp : desired POSIX timestamp for wind calculations
        - refList : simplified wnd file references [[valid_ts,avail_ts,rel_path]] generated by reshapeReferences function

    Returns :
        - list of length 2 containing first and last WND files info for interpolation. Each element possibly containing more than 
        1 reference to a WND file (then different interpolation schemes apply)
    """

    for i, elem in enumerate(refList):
        if len(elem) != 3 :
            refTimestamp = elem[0][0]
        else :
            refTimestamp = elem[0]
        
        if inTimestamp < refTimestamp :
            if i == 0:
                return [elem,refList[i+1]]
            else :
                return [refList[i-1],elem]


def parseWnd(inWndFilePath):

    """
    WND file parser from Yvon/Deepsink

    Gets an inWndFilePath string then :
        - gets the desired wnd file online
        - parses the file

    Returns a pandas dataframe containing, for each latitude from 90 to -90 (dataframe index), each longitude (from -180 to 179), u and v wind components

    TO DO : ne pas télécharger de nouveau le fichier si présent au moment du calcul
    """

    furl=f"https://static.virtualregatta.com/winds/{inWndFilePath}"


    
    r = requests.get(furl)
    
    buf = r.content

    uv=np.frombuffer(buf, dtype=np.int8).reshape((181,360,2))
    
    uv=np.sign(uv)*(uv/8)**2
    u=uv[:,:,0]
    v=uv[:,:,1]

    lats = [i for i in range(90,-91,-1)]
    lons = [i for i in range(-180, 180,1)]
    windDf = []
    for i in range(len(lats)) :
        for j in range(len(lons)) :
            windDf.append({'latitude': lats[i], 'longitude': lons[j], 'u': uv[i,j,0],'v':uv[i,j,1]})
    windDf = pd.DataFrame(windDf)
        
    return windDf

def windComponents(inLat, inLon, inWndDf):
    """
    Bilinear interpolation of U and V wind components for a given inLat (latitude) and inLon (longitude) based on a wind dataframe 
    
    Returns interpolated U and V values in m/s.
    """
    
    flooredLat = floor(inLat)
    ceiledLat = ceil(inLat)
    flooredLon = floor(inLon)
    ceiledLon= ceil(inLon)
    corner1Index = inWndDf.loc[(inWndDf['latitude'] == flooredLat) &  (inWndDf['longitude'] == flooredLon)].index
    corner2Index = inWndDf.loc[(inWndDf['latitude'] == ceiledLat) & (inWndDf['longitude'] == flooredLon)].index
    corner3Index = inWndDf.loc[(inWndDf['latitude'] == ceiledLat) & (inWndDf['longitude'] == ceiledLon)].index
    corner4Index = inWndDf.loc[(inWndDf['latitude'] == flooredLat) & (inWndDf['longitude'] == ceiledLon)].index

    lats = np.array([flooredLat,ceiledLat,ceiledLat,flooredLat],dtype='int32')
    lons = np.array([flooredLon,flooredLon,ceiledLon,ceiledLon],dtype='int32')

    uWind = np.array([inWndDf['u'][corner1Index],inWndDf['u'][corner2Index],inWndDf['u'][corner3Index],inWndDf['u'][corner4Index]], dtype = 'float64')
    uWindInterp = interpolate.interp2d(lats,lons,uWind)
    uInterpolated = uWindInterp(inLat,inLon)
        
    vWind = np.array([inWndDf['v'][corner1Index],inWndDf['v'][corner2Index],inWndDf['v'][corner3Index],inWndDf['v'][corner4Index]], dtype = 'float64')
    vWindInterp = interpolate.interp2d(lats,lons,vWind)
    vInterpolated = vWindInterp(inLat,inLon)

    return uInterpolated/3.6, vInterpolated/3.6

def windTwd(inU,inV):
    """
    TWD calculation
    Gets:
        - U and V wind components

    Returns:
        - True Wind Direction
    """
    return (270 - degrees(atan2(inV,inU)))%360

def windTimeInterp(inRefList,inTimeStamp):
    """
    Linear time interpolation for WND files

    Gets :
        - a list of [validt_ts, avail_ts, rel_path]
        - a timestamp for isochrone calculation

    Returns :
        - wind components interpolation coefficients for the given timestamp

    """
    validTs = []
    availTs = []
    relPath = []
    windCoeffs = []

    for elem in inRefList :
        if isinstance(elem[0],list):
            for subElem in elem :
                validTs.append(subElem[0])
                availTs.append(subElem[1])
                relPath.append(subElem[2])
        else :
            validTs.append(elem[0])
            availTs.append(elem[1])
            relPath.append(elem[2])

    if len(relPath) == 2:
        deltaT = validTs[1] - validTs[0]

        firstCoeff = (validTs[1] - inTimeStamp)/(deltaT)
        secondCoeff = (inTimeStamp - validTs[0])/(deltaT)

        windCoeffs = [firstCoeff,secondCoeff]

    else :
        deltaT1 = validTs[2] - inTimeStamp
        deltaT2 = validTs[2] - validTs[0]
        deltaT4 = validTs[2] - availTs[2]
        deltaT3 = inTimeStamp - availTs[2] 

        if deltaT3 < 0 :
            deltaT = validTs[1] - validTs[0]
            firstCoeff = (validTs[1] - inTimeStamp)/(deltaT)
            secondCoeff = (inTimeStamp - validTs[0])/(deltaT)
            thirdCoeff = 0.
        else :
            firstCoeff = deltaT1/(deltaT2)
            secondCoeff = deltaT1/(deltaT4)
            thirdCoeff = deltaT3/(deltaT4)
        
        windCoeffs = [firstCoeff,secondCoeff,thirdCoeff]

    return windCoeffs

def prepForWindDatas(inTimestamp):
    """
    Generates wind Dataframes and wind interpolation coefficient for a given inTimestamp
    """

    with open(os.path.join(sys.path[0],'projectMap.JSON'), "r") as directoriesFile :
            arborescence = json.load(directoriesFile)

    # set VR wind directory URL
    vrWndDir = arborescence['vrwind']

    # set storage directory path for WND files
    wndDir = arborescence['root'] + arborescence['storage']['data']['wnd']

    with open(os.path.join('/home/tom/MonBoat/Data/Wnd/Tmp_wnd/','references.json'), "w") as wndReferencesFile :
        wndFileMap = requests.get(os.path.join('https://static.virtualregatta.com/winds/live','references.json')).json()
        json.dump(wndFileMap, wndReferencesFile, indent=2)

    refList = reshapeReferences(wndFileMap['references'])

    refList = findWndFile(inTimestamp,refList)

    # # # Gets the interpolation coeffs for the given Timestamp
    windCoeffs = windTimeInterp(refList,inTimestamp)

    # # # Creation of Wind Dataframes
    windDf = []

    for i,elem in enumerate(refList):
        if len(elem) == 3 :
            windDf.append(parseWnd(elem[-1]))

        else :
            for subElem in elem:
                windDf.append(parseWnd(subElem[-1]))
   
    return windDf,windCoeffs

def windDatas(inLat, inLon, inWindDf, inWindCoeffs):
    """
    for a given (inLat,inLon) position at inTimestamp:

    Returns [wind modulus, TWD, U component, V component]

    """

    windU = []
    windV = []

    for wndDf in inWindDf :
        tmpU , tmpV = windComponents(inLat, inLon, wndDf)
        windU.append(tmpU[0])
        windV.append(tmpV[0])

    u,v = 0., 0.

    if len(inWindCoeffs) == 3 :
        u = inWindCoeffs[0]*windU[0] + (1-inWindCoeffs[0])*(inWindCoeffs[1]*windU[1]+inWindCoeffs[2]*windU[2])
        v = inWindCoeffs[0]*windV[0] + (1-inWindCoeffs[0])*(inWindCoeffs[1]*windV[1]+inWindCoeffs[2]*windV[2])
    else :
        u = inWindCoeffs[0]*windU[0] + inWindCoeffs[1]*windU[1]
        v = inWindCoeffs[0]*windV[0] + inWindCoeffs[1]*windV[1]

    windMod = sqrt(u**2 + v**2)
    
    return [windMod,windTwd(u,v),u,v]
    
